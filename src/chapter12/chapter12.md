# 상속 다루기

## 12.6 타입 코드를 서브클래스로 바꾸기

비슷한 대상들을 특정 특성에 따라 구분해야할 때 보통 type이라는 필드를 만들고 요거에 따라 분기를 쳐줌.

- 10.4 조건부 로직을 다형성으로 바꾸기와 비슷한 내용

```ts
// 10.4 예시
function plumage(bird: typeof birds[number]) {
  switch (bird.type) {
    case "europe": {
      return "노말";
    }
    case "africa": {
      return bird.numberOfCoconuts > 2 ? "지쳤다" : "보통이다";
    }
    case "norway": {
      return bird.voltage > 100 ? "그을렸다" : "예쁘다";
    }
    default:
      return "알 수 없다";
  }
}
```

보통은 이걸로도 불편하지 않지만, 서브클래스를 이용하면 두가지 장점을 더 얻을 수 있음

1. 조건에 따라 다르게 동작하도록 해주는 다형성

- 특별한 분기 없이 같은 메서드를 통해 다른 동작을 적용 가능

2. 특정 타입에서만 의미 있는 값을 명확하게 보여줌

- 특정 타입에서만 사용된다면 해당 서브클래스에서만 속성을 정의하면 됨

적용하는 방식은 두가지가 있다.

1. 대상 클래스 (슈퍼클래스)에 직접 적용하는 방법

- 대상 클래스를 상속받는 서브클래스를 여러개 만드는 방식
- 간단하지만 서브클래스를 다른 방식으로 쓰고 싶을 때 (현재 구분해야할 타입대신 다른걸 구분하고 싶을 때)는 사용하기 애매함

2. 새로 클래스(인터페이스)를 만들고 그 클래스를 상속받도록 적용하는 방식

- 1번의 단점 해결 가능하지만 조금 복잡

## 12.7 서브클래스 제거하기

- 12.6 타입 코드를 서브클래스로 바꾸기의 반대개념
- 시스템이 변경되면서 서브클래스로 나눈게 가치가 없어진 경우 다시 슈퍼클래스의 필드로 대체하는 방법
  - 괜히 왜 나뉘어졌는지 이해하는데 더 시간이 걸린다

**절차**

1. 서브클래스의 생성자를 팩토리 함수로 변경
   -> 생성자를 사용하는 쪽 로직을 확인해서 그 로직을 슈퍼클래스의 팩터리 메서드에 넣는다
2. 서브클래스의 타입을 검사하는 코드가 있으면 함수 추출하기, 함수 옮기기를 사용해서 슈퍼클래스로 옮긴다
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다
4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다
5. 서브클래스를 지운다

## 12.8 슈퍼클래스 추출하기

- 비슷한 일을 수행하는 클래스가 보이면 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담기
  - 데이터 - 12.2 필드 올리기
  - 동작 - 12.1 메서드 올리기
- 구현에 들어가기 전에 신중하게 구조를 잡아서 설계시부터 상속 구조를 잡는 경우도 있지만, 프로그램이 성장하면서 슈퍼클래스로 올리고 싶은 공통 요소를 찾았을 때 수행하는 경우가 많음
- 7.5 클래스 추출하기를 대안으로 사용할 수도 있음 (위임으로 해결하는 방법)
  - 슈퍼클래스 추출이 더 간단하므로 이 방법을 먼저 시도해보고, 필요해지면 12.11 슈퍼클래스를 위임으로 바꾸기를 사용하여 변경하기
  - 예전에 배웠던 is-a, has-a 의 그 상속과 위임..
  - 슈퍼클래스의 모든 기능을 사용하면서 확장해서 수행할 때 상속(아예 대체 가능해야함), 그냥 기능만 복사해서 사용하는 경우 위임

**절차**

1. 빈 슈퍼클래스를 만들고 이 클래스를 상속하도록 변경
2. 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 적용하여 공통 원소를 슈퍼클래스로 옮기기
3. 서브클래스에 남은 메서드 중 공통되는 부분이 있으면 함수로 추출하고 메서드 올리기
4. 원래 클래스들을 사용하는 코드에서 슈퍼클래스의 인터페이스를 사용할지 검토
