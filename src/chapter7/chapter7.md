## 레코드 캡슐화하기

- 데이터 레코드(js에서 리터럴 객체형태)는 값을 의미있는 단위로 전달할 수 있게 해주지만 부족한 경우가 있음.
- 이 때, 클래스를 사용하면 이 부족한 점을 채울 수 있음.
  - 외부에서 데이터 접근을 하지 못하도록 만들 수 있음.
  - 무엇이 저장된 값인지, 계산된 값인지 알 필요 없음.
    - 계산된 값이 뭔지 알아가면서 계속 바꿔줄 필요 없음.
  - 네이밍도 바꾸기 편함. (필드 이름을 바꿔도 메서드는 그대로)
- 불변 객체를 사용하면 저장된 값, 계산된 값 문제는 해결 가능
  - 기존 필드 변경 없이 새로 구해서 객체를 새로 만들면 됨.
- 중첩된 레코드인 경우 캡슐화를 재귀적으로 적용
  - 1depth 캡슐화, 2depth 캡슐화 ...

## 컬렉션 캡슐화하기

- 원본 컬렉션에 대한 직접적인 변경을 못하도록 함
  - 절대 컬렉션 원본을 반환하지 않는 방법이 있을 수 있음
    - 단, 많이 사용되는 `map` 등을 사용한 컬렉션 파이프라인 패턴을 사용하기 힘듬.
  - 또는 프록시 사용
    - get은 가능하게, set은 불가능하게
  - 아니면 읽기 전용으로 제공
    - 원본 컬렉션의 복사본 제공하기.
    - 매우 큰 컬렉션이 아니면 성능 문제가 발생할 일은 크게 없음.
      - 일단 측정을 하고, 문제가 되면 수정
  - 이 중 하나만 제공하여 코드베이스에 일관성을 제공하는게 중요함.

## 기본형 객체로 바꾸기

- 단순한 정보를 숫자나 문자열로 표현하고 있을 때, 개발이 진행되면서 추가적인 로직이 들어가는 경우가 있음
  - 예를들어, 전화번호라고 하면 formatting이나 지역코드 추출 등
- 출력 이상의 기능이 필요해지면 데이터를 표현하는 전용 클래스를 생성
- 초기에는 기본형 데이터를 감싼 수준이라도, 로직이 조금씩 추가되면 굉장히 유용해짐

## 임시 변수를 질의 함수로 바꾸기

- 함수 안에서 어떤 로직의 결괏값을 다시 참조하기 위해 임시 변수를 사용하는데, 이걸 함수로 만들어 사용하는 방법
- 큰 함수의 부분을 별도 함수로 추출할 때 이 변수들이 함수로 만들어져있으면 리팩토링이 쉬워짐
  - 추출한 함수에 변수를 따로 전달할 필요가 없어짐. (클래스일 때나 전역변수 사용하는 케이스인 듯함)
  - 추출한 함수와 원래 함수의 경계가 분명해져서 의존관계 파악이 쉬워짐.
- 함수로 추출하면 비슷한 로직이 있는 다른 함수에서도 사용이 가능
- 클래스일 때 효과적인 방법.
  - 공유 컨텍스트가 있기 때문.
- 주의할 점은, 이 로직이 항상 똑같은 결과를 내야한다는 점.
  - 계산된 결과를 계속 가지고 있는게 아니라 사용할 때 계산하므로, 계산할 때마다 다른 결과를 내면 안됨.
