## Chapter 6 기본적인 리팩토링

### 6.6 변수 캡슐화하기

- 변수를 직접 사용하게 되면 변경에 취약하다.
  - 예를들어 함수를 사용하게 되면 일단 그 함수가 다른 함수를 호출하도록 바꾼 후 수정하면 되지만, 변수를 사용하게 되면 그 변수를 참조하는 모든 곳을 한번에 바꿔줘야함.
- 데이터 변경을 한 곳에서 처리 가능
  - 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워넣을 수 있다.
- 불변 데이터는 캡슐화할 이유가 적음
  - 변경될 일이 없어서 위와 같은 변경 전 검증을 할 필요가 없기 때문
- 레코드 형태라면 필요에 따라 레코드 캡슐화를 진행
  - 변경을 막아버릴 수 있음

```ts
let defaultOwner = { firstName: "태희", lastName: "이" };

let getDefaultOwner = () => defaultOwner;

// 변수가 변경되는 경우
const newDefaultOwner = { firstName: "태희", lastName: "김" };

// getDefaultOwner 를 다음과 같이 먼저 변경한 후 리팩토링 가능
// let getDefaultOwner = () => newGetDefaultOwner();

const setDefaultOwner = (data: any) => {
  // 데이터 검증 / 사전 처리
  defaultOwner = data;
  // 데이터 사후 처리
};
```

- 데이터의 사용 범위가 넓을수록 적절하게 캡슐화 하는게 좋다.

### 6.7 변수 이름 바꾸기

- 맥락으로 부터 변수 목적을 알 수 있는 경우는 조금 짧게 지어도 괜찮지만, 계속 존재하는 값이라면 신경을 많이 써서 짓자.
- 폭넓게 쓰이는 변수라면변수 캡슐화하기를 고려
- 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서 하나씩 변경
  - 이 때 점진적으로 변경 가능

```ts
// 상수를 바꾸는 경우
const cpyNm = "애플";

// 변경할 이름의 상수를 만들고 기존 상수 대체
const companyName = "애플";
const cpyNm = companyName;
```

### 6.8 매개변수 객체 만들기

- 데이터 항목을 여러개 함수로 넘겨주는 경우 요 데이터를 하나로 묶는 방법
- 더 나아가서 이 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만들 수 있음
  - 예를들어, 클래스를 만들어서 넘겨줄 수 있음

1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만들기

- 이왕이면 클래스 (동작까지 묶기 좋음)

2. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가
3. 함수 호출 시 새 데이터 구조의 인스턴스를 넘김
4. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 변경
5. 기존 매개변수 제거
