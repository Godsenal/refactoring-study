# 조건부 로직 간소화

조건부 로직은 프로그램을 복잡하게 만드는 주요 원흉
이해하기 쉽게 만드는 것이 중요하기 때문에 간소화하는 리팩토링이 중요하다.

## 10.1 조건문 분해하기

- 6.1에 나왔던 함수 추출하기를 조건부 식에 적용하는 방법
- 긴 조건문을 함수로 분리하여 짧게 만들고 + **함수 이름으로 해당 조건문의 의도를 파악할 수 있도록 함**
  - 무엇을 분기했는지, 분기한 이유가 무엇인지 명확해진다.

## 10.2 조건식 통합하기

- 조건은 다른데 결과는 동일한 경우 조건식을 통합하는 방법
  - 단, 독립된 검사라고 판단이 되면 이 리팩토링을 진행해서는 안됨.
- 통합하는 이유는 두가지

1. 여러 조각으로 나뉜 조건들을 하나로 통합해서 하려는 일을 명확하게 볼 수 있음

- 동일한 결과를 내는 조건을 한 컨텍스트로 묶어서 볼 수 있음

2. 함수 추출하기 (조건문 분해하기) 까지 이어질 수 있음

- 즉, 조건문 분해하기의 장점 (의도를 파악할 수 있게하는 점)을 가져올 수 있음

### 절차

1. 조건식들에 side effect가 있는지 확인

- 그럴일은 없겠지만 조건문을 통해 다른 값이 바뀐다거나.. 하는 부분을 확인하고 있으면, 11.1의 질의 함수와 변경함수 분리하기를 선적용

2. 조건문 두 개를 선택하여 논리연산자로 결합 (&&, ||)

- 레벨이 같은 경우 ||, 중첩된 경우 &&

3. 테스트
4. 조건 하나만 남을 때까지 2~3 반복
5. 조건식을 분해할지 결정

## 10.3 중첩 조건문을 보호 구문으로 바꾸기

- 조건문은 주로 두 가지 형태

1. 참 / 거짓 모두 정상 동작인 경우
   - 10.1 예제처럼 참 / 거짓일 때 값만 달라지는 경우
2. 한쪽만 정상인 경우
   - 로딩 중에 실행을 막거나 하는 경우

- 여기서 두번째를 보통 보호구문 (guard clause) 라고 함
- 2번의 경우 함수를 빠져나와서 이 함수의 핵심이 아니라는걸 명확하게 보여주도록 하는 방법
- 함수의 진입점은 하나지만, 반환점은 하나일 필요가 없다.

### 절차

1. 교체해야 할 조건 중 가장 바깥 것을 보호 구문으로 바꿈
2. 테스트
3. 1~2 반복
4. 모든 보호 구문이 같은 결과를 반환하면 10.2 조건문 통합하기를 진행

## 10.4 조건부 로직을 다형성으로 바꾸기

- 타입(클래스)이 여러개 있을 때 조건부 로직을 타입별 방식대로 처리하도록 구성하는 방법
  - 이미 클래스로 나누어져 있는 경우에는 당연히 적용할 수 있고, 이러한 형태를 보고 클래스로 뽑는게 필요가 있다는 생각이 들 수도 있음
- 복잡한 조건부 로직을 발견하면 다형성이 도움이 될 때가 많다.
  - 조건부 로직만을 위해서 클래스로 나누어져 있지 않은 부분을 클래스로 뽑는건 과할 수도 있을 것 같고, 추가적으로 클래스가 유용해보이는 부분이 있으면 생각해 볼 수 있을 것 같다.

### 절차

1. 다형적 동작을 표현하는 클래스가 없다면 생성. 이왕이면 팩토리함수까지 생성.
2. 호출하는 코드에서 팩터리 함수를 사용하도록 변경.
3. 조건부 로직 함수를 슈퍼클래스로 분리
4. 서브클래스에서 슈퍼클래스의 조건부 로직 메서드를 오버라이드. (자신의 케이스에 해당하는 부분)
5. 다른 서브클래스도 적용
6. 슈퍼클래스 메서드에는 기본 동작부분만 남김 (기본 동작이 필요한 경우)
